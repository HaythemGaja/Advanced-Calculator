<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Web App Manifest -->
    <link rel="manifest" href="manifest.json">
    <!-- Theme Color for Browser UI -->
    <meta name="theme-color" content="#8b5cf6">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .calculator-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }
        .btn {
            @apply w-full h-16 text-2xl rounded-lg shadow-md transition-all duration-200 ease-in-out flex items-center justify-center;
        }
        .btn-number {
            @apply bg-white text-gray-800 hover:bg-gray-200 active:shadow-inner;
        }
        .btn-operator {
            @apply bg-blue-500 text-white hover:bg-blue-600 active:shadow-inner;
        }
        .btn-func {
            @apply bg-purple-500 text-white hover:bg-purple-600 active:shadow-inner text-xl;
        }
        .btn-action {
            @apply bg-gray-300 text-gray-800 hover:bg-gray-400 active:shadow-inner;
        }
        .btn-equals {
            @apply bg-green-500 text-white hover:bg-green-600 active:shadow-inner;
        }
        .history-item-row {
            @apply border-b border-gray-200 cursor-pointer;
        }
        .history-item-row:hover {
            background-color: #e9e9ed;
        }
        .new-chain-start {
            border-top: 2px solid #8b5cf6; /* purple-500 */
        }
        .display-text {
            @apply w-full bg-transparent text-right text-gray-400 text-xl h-8 overflow-x-auto overflow-y-hidden whitespace-nowrap;
        }
        /* Style for the contenteditable display to remove focus outline */
        .display-text[contenteditable]:focus {
            outline: 0px solid transparent;
        }
        .display-input {
            @apply w-full text-right text-xl h-9 rounded-md focus:ring-0 focus:outline-none p-1;
            background-color: #000 !important;
            border: 1px solid #fff !important;
            color: #ef4444 !important; /* Red-500 */
        }
        .highlight-update {
            animation: highlight-animation 2s ease-out;
        }
        @keyframes highlight-animation {
            0% { background-color: #fef9c3; } /* yellow-100 */
            100% { background-color: transparent; }
        }
        input:-webkit-autofill,
        input:-webkit-autofill:hover,
        input:-webkit-autofill:focus,
        input:-webkit-autofill:active{
            -webkit-box-shadow: 0 0 0 30px #000000 inset !important;
            -webkit-text-fill-color: #ef4444 !important;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="w-full max-w-5xl mx-auto bg-white rounded-2xl shadow-2xl p-6 md:p-8 grid md:grid-cols-2 gap-8">
        <!-- Calculator Section -->
        <div class="md:col-span-1">
            <h1 class="text-3xl font-bold text-gray-800 mb-4">Calculator</h1>
            <!-- Display -->
            <div class="bg-black text-white rounded-lg p-4 mb-6 shadow-inner text-right">
                <div id="expression-display-text" class="display-text" contenteditable="true" spellcheck="false"></div>
                <input type="text" id="expression-display-input" class="display-input hidden" autocomplete="off">
                <div id="live-result-display" class="text-4xl font-semibold min-h-[3rem]">0</div>
            </div>
            <!-- Buttons -->
            <div class="calculator-grid">
                <button class="btn btn-func" onclick="changeRoundingPrecision()">Round</button>
                <button class="btn btn-func" onclick="appendString('Math.sqrt(')">sqrt</button>
                <button class="btn btn-operator" onclick="appendOperator('^')">^</button>
                <button class="btn btn-func" onclick="appendString('(')">(</button>
                <button class="btn btn-action" onclick="clearAll()">AC</button>
                <button class="btn btn-action" onclick="deleteLast()">C</button>
                <button class="btn btn-operator" onclick="appendOperator('/')">÷</button>
                <button class="btn btn-operator" onclick="appendOperator('*')">×</button>
                <button class="btn btn-number" onclick="appendNumber('7')">7</button>
                <button class="btn btn-number" onclick="appendNumber('8')">8</button>
                <button class="btn btn-number" onclick="appendNumber('9')">9</button>
                <button class="btn btn-operator" onclick="appendOperator('-')">−</button>
                <button class="btn btn-number" onclick="appendNumber('4')">4</button>
                <button class="btn btn-number" onclick="appendNumber('5')">5</button>
                <button class="btn btn-number" onclick="appendNumber('6')">6</button>
                <button class="btn btn-operator" onclick="appendOperator('+')">+</button>
                <button class="btn btn-number" onclick="appendNumber('1')">1</button>
                <button class="btn btn-number" onclick="appendNumber('2')">2</button>
                <button class="btn btn-number" onclick="appendNumber('3')">3</button>
                <button class="btn btn-equals row-span-2" onclick="calculate()">=</button>
                <button class="btn btn-number col-span-2" onclick="appendNumber('0')">0</button>
                <button class="btn btn-number" onclick="appendNumber('.')">.</button>
            </div>
             <div id="results-container" class="mt-6 p-4 bg-gray-50 rounded-lg shadow hidden">
                <h3 class="text-lg font-semibold text-gray-700 mb-3">Use Result in Next Operation</h3>
                <div id="decimal-places" class="space-y-1 text-gray-600"></div>
            </div>
        </div>
        <!-- History Section -->
        <div class="md:col-span-1">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">History</h2>
            <div id="history-panel" class="bg-gray-100 p-2 rounded-lg shadow-inner h-[32rem] overflow-y-auto">
                <table id="history-table" class="w-full text-left table-fixed hidden">
                    <thead class="sticky top-0 bg-gray-100 shadow-sm">
                        <tr>
                            <th class="p-2 font-semibold text-gray-600 w-3/5">Calculation</th>
                            <th class="p-2 font-semibold text-gray-600 w-2/5">Result</th>
                            <th class="p-2"></th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body"></tbody>
                </table>
                <p id="no-history" class="text-gray-500 text-center mt-4">No calculations yet.</p>
            </div>
            <button class="w-full mt-4 py-2 px-4 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors" onclick="clearHistory()">Clear History</button>
        </div>
    </div>

    <!-- History Permission Modal -->
    <div id="permission-modal-overlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div id="permission-modal" class="bg-white p-8 rounded-lg shadow-xl max-w-sm w-full">
            <h3 class="text-lg font-bold mb-4">Save History?</h3>
            <p class="text-gray-600 mb-6">Do you want to save your calculation history for future visits?</p>
            <div class="flex justify-end space-x-4">
                <button id="decline-save" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">No, Thanks</button>
                <button id="confirm-save" class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600">Yes, Save</button>
            </div>
        </div>
    </div>

    <script>
        // DOM Element References
        const expressionDisplayText = document.getElementById('expression-display-text');
        const expressionDisplayInput = document.getElementById('expression-display-input');
        const liveResultDisplay = document.getElementById('live-result-display');
        const historyPanel = document.getElementById('history-panel');
        const historyTable = document.getElementById('history-table');
        const historyTableBody = document.getElementById('history-table-body');
        const noHistoryMessage = document.getElementById('no-history');
        const resultsContainer = document.getElementById('results-container');
        const decimalPlacesContainer = document.getElementById('decimal-places');
        const permissionModalOverlay = document.getElementById('permission-modal-overlay');
        const confirmSaveBtn = document.getElementById('confirm-save');
        const declineSaveBtn = document.getElementById('decline-save');

        // State Variables
        let currentExpression = '';
        let history = [];
        let editingHistoryId = null;
        let isResultOnScreen = false;
        let activeRounding = null; 
        let lastFullResult = null; 
        let roundingDecimalPlaces = null;

        // --- Core Calculator Logic ---

        function appendNumber(number) {
            if (isResultOnScreen) {
                currentExpression = '';
                isResultOnScreen = false;
                activeRounding = null;
                lastFullResult = null;
            }
            if (number === '.' && currentExpression.split(/[\+\-\*\/^]/).pop().includes('.')) return;
            currentExpression += number;
            updateDisplay();
        }

        function appendOperator(operator) {
            if (isResultOnScreen) {
                isResultOnScreen = false;
            }
            const lastChar = currentExpression.slice(-1);
            if (currentExpression === '' && operator !== '-') return;
            if (/[\+\-\*\/^]$/.test(currentExpression)) return;
            currentExpression += operator;
            updateDisplay();
        }

        function appendString(str) {
            if (isResultOnScreen) {
                if (str === 'Math.sqrt(') {
                    currentExpression = `Math.sqrt(${currentExpression})`;
                } else if (str === '(') {
                    currentExpression = '(';
                }
                isResultOnScreen = false;
                activeRounding = null;
                lastFullResult = null;
            } else {
                currentExpression += str;
            }
            updateDisplay();
        }

        function deleteLast() {
            if (isResultOnScreen) return;
            currentExpression = currentExpression.slice(0, -1);
            updateDisplay();
        }

        function clearAll() {
            currentExpression = '';
            editingHistoryId = null;
            isResultOnScreen = false;
            activeRounding = null;
            lastFullResult = null;
            roundingDecimalPlaces = null;
            expressionDisplayText.classList.remove('hidden');
            expressionDisplayInput.classList.add('hidden');
            resultsContainer.classList.add('hidden');
            updateDisplay();
        }

        // --- Display Updates ---

        function updateDisplay() {
            let display = currentExpression.replace(/\*/g, '×').replace(/\//g, '÷');
            expressionDisplayText.textContent = display || '0';
            liveUpdate();
        }

        function sanitizeForCalculation(expr) {
            // This function prepares the expression string for evaluation by `new Function()`
            return expr.replace(/×/g, '*').replace(/÷/g, '/').replace(/\^/g, '**');
        }

        function liveUpdate() {
            if (isResultOnScreen) return;
            let expr = editingHistoryId ? expressionDisplayInput.value : currentExpression;
            if (expr === '') {
                liveResultDisplay.textContent = '0';
                return;
            }
            try {
                let sanitizedExpression = sanitizeForCalculation(expr);
                let expressionToEvaluate = sanitizedExpression;
                // Don't evaluate if the expression ends with an operator
                if (/[\+\-\*\/]$/.test(sanitizedExpression)) {
                    expressionToEvaluate = sanitizedExpression.slice(0, -1);
                }
                // Basic check for parenthesis balance
                const openParen = (expressionToEvaluate.match(/\(/g) || []).length;
                const closeParen = (expressionToEvaluate.match(/\)/g) || []).length;
                if (openParen > closeParen) {
                    liveResultDisplay.textContent = '...';
                    return;
                }
                if (expressionToEvaluate === '') {
                    liveResultDisplay.textContent = '0';
                    return;
                }
                const result = new Function('return ' + expressionToEvaluate)();
                liveResultDisplay.textContent = formatResult(result);
            } catch (error) {
                liveResultDisplay.textContent = '...';
            }
        }

        // --- Calculation and Result Handling ---

        function calculate() {
            let exprToCalc = editingHistoryId ? expressionDisplayInput.value : currentExpression;
            let sanitizedExpression = sanitizeForCalculation(exprToCalc);
            if (sanitizedExpression === '' || /[\+\-\*\/]$/.test(sanitizedExpression)) return;
            try {
                const result = new Function('return ' + sanitizedExpression)();
                let finalResultToDisplay = result;
                
                let displayExpressionForHistory = sanitizedExpression;
                if (activeRounding && sanitizedExpression.startsWith(activeRounding.rounded)) {
                    const operationPart = sanitizedExpression.substring(activeRounding.rounded.length);
                    displayExpressionForHistory = `round(${String(activeRounding.original)}, ${activeRounding.dp})${operationPart}`;
                }

                if (editingHistoryId !== null) {
                    const itemIndex = history.findIndex(item => item.id === editingHistoryId);
                    if (itemIndex > -1) {
                        const editedItem = history[itemIndex];
                        editedItem.expression = sanitizedExpression;
                        editedItem.result = result;
                        editedItem.displayExpression = sanitizedExpression; // Keep it simple on edit
                        editedItem.highlight = true;

                        if (itemIndex > 0) {
                            const prevResultStr = String(history[itemIndex - 1].result);
                            if (sanitizedExpression.startsWith(prevResultStr)) {
                                editedItem.isContinuation = true;
                                editedItem.operationPart = sanitizedExpression.substring(prevResultStr.length);
                            } else {
                                editedItem.isContinuation = false;
                                editedItem.operationPart = '';
                            }
                        } else {
                            editedItem.isContinuation = false;
                            editedItem.operationPart = '';
                        }
                        const lastAffectedIndex = updateSubsequentHistory(itemIndex);
                        finalResultToDisplay = history[lastAffectedIndex].result;
                    }
                } else {
                    addToHistory(sanitizedExpression, result, displayExpressionForHistory);
                }
                
                // After the first successful calculation, check if we need to ask for permission.
                if (localStorage.getItem('saveHistoryPermission') === null) {
                    permissionModalOverlay.classList.remove('hidden');
                }

                renderHistory();
                displayDecimalPlaces(result);
                currentExpression = String(finalResultToDisplay);
                editingHistoryId = null;
                isResultOnScreen = true;
                lastFullResult = result; // Store for rounding cycle
                roundingDecimalPlaces = null; // Reset rounding state for the next calculation
                activeRounding = null;
                
                expressionDisplayText.classList.remove('hidden');
                expressionDisplayInput.classList.add('hidden');
                updateDisplay();
                liveResultDisplay.textContent = formatResult(finalResultToDisplay);
                resultsContainer.classList.remove('hidden');
            } catch (error) {
                liveResultDisplay.textContent = 'Error';
                clearAll();
                updateDisplay();
            }
        }

        function useResult(original, rounded, dp) {
            currentExpression = String(rounded);
            if (dp !== null) {
                activeRounding = { original, rounded: String(rounded), dp };
            } else {
                activeRounding = null;
            }
            isResultOnScreen = false;
            resultsContainer.classList.add('hidden');
            updateDisplay();
            liveResultDisplay.textContent = formatResult(rounded);
        }
        
        function countDecimalPlaces(num) {
            if (!Number.isFinite(num) || num % 1 === 0) {
                return 0;
            }
            // Convert to string and get the part after the decimal point
            return num.toString().split('.')[1].length;
        }

        function changeRoundingPrecision() {
            if (!isResultOnScreen || lastFullResult === null || !Number.isFinite(lastFullResult) || lastFullResult % 1 === 0) {
                return;
            }

            let nextDp;
            const maxDp = countDecimalPlaces(lastFullResult);

            if (roundingDecimalPlaces === null) {
                // First click: Start with the full number of decimal places.
                nextDp = maxDp;
            } else {
                // Subsequent clicks: Reduce by one.
                nextDp = roundingDecimalPlaces - 1;
            }
            
            // Update the state for the *next* click
            roundingDecimalPlaces = nextDp;

            let resultToDisplay;
            if (roundingDecimalPlaces < 0) {
                // Cycle back to the full result.
                roundingDecimalPlaces = null; // Reset for the next cycle.
                resultToDisplay = lastFullResult;
                activeRounding = null;
            } else {
                resultToDisplay = Number(lastFullResult).toFixed(roundingDecimalPlaces);
                activeRounding = { original: lastFullResult, rounded: resultToDisplay, dp: roundingDecimalPlaces };
            }
            
            currentExpression = String(resultToDisplay);
            expressionDisplayText.textContent = formatResult(resultToDisplay);
            liveResultDisplay.textContent = formatResult(resultToDisplay);
        }

        function displayDecimalPlaces(result) {
            decimalPlacesContainer.innerHTML = '';

            // If result is not a finite number, just display it and stop.
            if (!Number.isFinite(result)) {
                const nonFiniteResultDiv = document.createElement('div');
                nonFiniteResultDiv.className = 'flex justify-between items-center py-1';
                nonFiniteResultDiv.innerHTML = `
                    <div>
                        <span class="font-semibold">Result:</span>
                        <span class="font-mono ml-2 text-blue-600">${formatResult(result)}</span>
                    </div>
                `;
                decimalPlacesContainer.appendChild(nonFiniteResultDiv);
                return;
            }

            const places = [10, 8, 5, 4, 3, 2, 1, 0].filter(dp => {
                const actualDp = countDecimalPlaces(result);
                return dp <= actualDp;
            });
            
            const fullResultDiv = document.createElement('div');
            fullResultDiv.className = 'flex justify-between items-center py-1';
            fullResultDiv.innerHTML = `
                <div>
                    <span class="font-semibold">Full:</span>
                    <span class="font-mono ml-2 text-blue-600">${formatResult(result)}</span>
                </div>
                <button class="px-3 py-1 bg-indigo-500 text-white text-xs font-semibold rounded-md hover:bg-indigo-600 transition-colors" onclick="useResult(${result}, ${result}, null)">Use</button>
            `;
            decimalPlacesContainer.appendChild(fullResultDiv);

            places.forEach(dp => {
                const dpResult = Number(result).toFixed(dp);
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center py-1';
                div.innerHTML = `
                     <div>
                         <span class="text-sm">${dp} dec:</span>
                         <span class="font-mono ml-2">${formatDecimalString(dpResult)}</span>
                     </div>
                    <button class="px-3 py-1 bg-indigo-500 text-white text-xs font-semibold rounded-md hover:bg-indigo-600 transition-colors" onclick="useResult(${result}, '${dpResult}', ${dp})">Use</button>
                `;
                decimalPlacesContainer.appendChild(div);
            });
        }

        // --- Formatting Helpers ---

        function formatResult(number) {
            if (isNaN(number)) return 'Error';

            // Using Number() handles both number and string inputs.
            // toLocaleString is a more direct and robust way to format for display,
            // avoiding issues with toPrecision().
            return Number(number).toLocaleString('en-US', {
                maximumFractionDigits: 10
            });
        }

        function formatDecimalString(numStr) {
            const [integerPart, decimalPart] = numStr.split('.');
            const formattedIntegerPart = Number(integerPart).toLocaleString('en-US');
            return decimalPart !== undefined ? `${formattedIntegerPart}.${decimalPart}` : formattedIntegerPart;
        }

        // --- Clipboard Helper ---
        function copyToClipboard(text, element) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            textarea.setAttribute('readonly', '');
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                // Provide visual feedback on the button that was clicked
                if (element) {
                    const originalIcon = element.innerHTML;
                    element.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check-lg text-green-500" viewBox="0 0 16 16">
                          <path d="M12.736 3.97a.733.733 0 0 1 1.047 0c.286.289.29.756.01 1.05L7.88 12.01a.733.733 0 0 1-1.065.02L3.217 8.384a.757.757 0 0 1 0-1.06.733.733 0 0 1 1.047 0l3.052 3.093 5.4-6.425a.247.247 0 0 1 .02-.022z"/>
                        </svg>
                    `;
                    setTimeout(() => {
                        element.innerHTML = originalIcon;
                    }, 1500);
                }
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
            document.body.removeChild(textarea);
        }


        // --- History Management ---

        function addToHistory(calcExpression, result, displayExpression) {
            let isContinuation = false;
            let operationPart = '';
            if (history.length > 0 && !editingHistoryId) {
                const prevResultStr = String(history[history.length - 1].result);
                if (calcExpression.startsWith(prevResultStr)) {
                    isContinuation = true;
                    operationPart = calcExpression.substring(prevResultStr.length);
                }
            }
            const historyItem = { 
                id: Date.now(), 
                expression: calcExpression, 
                displayExpression: displayExpression || calcExpression,
                result, 
                isContinuation, 
                operationPart 
            };
            history.push(historyItem);
        }

        function renderHistory() {
            historyTableBody.innerHTML = '';
            if (history.length === 0) {
                historyTable.classList.add('hidden');
                noHistoryMessage.classList.remove('hidden');
            } else {
                historyTable.classList.remove('hidden');
                noHistoryMessage.classList.add('hidden');
                history.forEach((item, index) => {
                    const tr = document.createElement('tr');
                    tr.className = 'history-item-row';
                    if (item.highlight) {
                        tr.classList.add('highlight-update');
                        delete item.highlight;
                    }
                    if (index === 0 || !item.isContinuation) {
                        tr.classList.add('new-chain-start');
                    }
                    tr.dataset.id = item.id;
                    tr.ondblclick = () => loadFromHistory(item.id);
                    const displayExpression = item.displayExpression.replace(/\*/g, '×').replace(/\//g, '÷').replace(/\*\*/g, '^');
                    tr.innerHTML = `
                        <td class="p-2 break-words text-gray-700">${displayExpression}</td>
                        <td class="p-2 font-semibold text-blue-700 break-words">${formatResult(item.result)}</td>
                        <td class="p-2">
                            <div class="flex justify-center items-center space-x-3">
                                <button class="text-gray-400 hover:text-blue-500 transition-colors" title="Copy result" onclick="copyToClipboard('${item.result}', this)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/>
                                        <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/>
                                    </svg>
                                </button>
                                <button class="text-red-400 hover:text-red-600 font-bold transition-colors" title="Delete entry" onclick="deleteHistoryItem(event, ${item.id})">X</button>
                            </div>
                        </td>
                    `;
                    historyTableBody.appendChild(tr);
                });
                historyPanel.scrollTop = historyPanel.scrollHeight;
            }
            // Save history to localStorage only if permission has been granted.
            if (localStorage.getItem('saveHistoryPermission') === 'true') {
                localStorage.setItem('calculatorHistory', JSON.stringify(history));
            }
        }

        function loadFromHistory(id) {
            const item = history.find(i => i.id === id);
            if (item) {
                clearAll();
                editingHistoryId = id;
                isResultOnScreen = false;
                expressionDisplayText.classList.add('hidden');
                expressionDisplayInput.classList.remove('hidden');
                let displayValue = item.expression.replace(/\*/g, '×').replace(/\//g, '÷').replace(/\*\*/g, '^');
                expressionDisplayInput.value = displayValue;
                expressionDisplayInput.focus();
                liveUpdate();
            }
        }

        function updateSubsequentHistory(startIndex) {
            let lastIndex = startIndex;
            for (let i = startIndex + 1; i < history.length; i++) {
                if (history[i].isContinuation) {
                    const prevItemNewResult = history[i - 1].result;
                    const newExpression = String(prevItemNewResult) + history[i].operationPart;
                    try {
                        const newResult = new Function('return ' + sanitizeForCalculation(newExpression))();
                        history[i].expression = newExpression;
                        history[i].result = newResult;
                        history[i].displayExpression = newExpression; // Update display to reflect new reality
                        history[i].highlight = true;
                        lastIndex = i;
                    } catch (e) {
                        // If an update fails, the chain is broken. Stop propagating changes.
                        history[i].isContinuation = false;
                        break;
                    }
                } else {
                    // Chain is broken
                    break;
                }
            }
            return lastIndex;
        }

        function deleteHistoryItem(event, id) {
            event.stopPropagation();
            const itemIndex = history.findIndex(item => item.id === id);
            if (itemIndex > -1) {
                history.splice(itemIndex, 1);
                
                // If there's an item that came after the deleted one, it's no longer a continuation.
                if (itemIndex < history.length) {
                    history[itemIndex].isContinuation = false;
                    history[itemIndex].operationPart = '';
                }
                
                renderHistory();
            }
        }

        function clearHistory() {
            history = [];
            renderHistory();
        }

        // --- Event Listeners ---
        expressionDisplayInput.addEventListener('input', liveUpdate);

        // A single, global paste handler to catch all paste events (right-click, Ctrl+V, etc.)
        document.addEventListener('paste', (e) => {
            // If the user is editing the history input, let that input handle the paste natively.
            if (document.activeElement === expressionDisplayInput) {
                return;
            }

            // Otherwise, we handle the paste for the main calculator display.
            e.preventDefault();
            const pasteData = (e.clipboardData || window.clipboardData).getData('text/plain');
            
            if (!pasteData) return;

            if (isResultOnScreen) {
                currentExpression = '';
                isResultOnScreen = false;
                activeRounding = null;
                lastFullResult = null;
            }

            currentExpression += pasteData;
            updateDisplay();
        });

        // Global keydown listener for keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Allow default behavior for Tab key and standard copy/cut/paste shortcuts
            // to avoid interfering with the new paste handler and browser functionality.
            if (e.key === 'Tab' || ((e.ctrlKey || e.metaKey) && ['c', 'x', 'v'].includes(e.key.toLowerCase()))) {
                return;
            }

            // If editing history, let the input field handle keys
            if (document.activeElement === expressionDisplayInput) {
                if (e.key === 'Enter') calculate();
                return;
            }

            // Prevent default for all other keys to manually control the calculator
            e.preventDefault();
            
            if (e.key >= '0' && e.key <= '9') appendNumber(e.key);
            else if (e.key === '.') appendNumber('.');
            else if (['+', '-', '*', '/', '^'].includes(e.key)) appendOperator(e.key);
            else if (['(', ')'].includes(e.key)) appendString(e.key);
            else if (e.key === 'Enter' || e.key === '=') calculate();
            else if (e.key === 'Backspace') deleteLast();
            else if (e.key.toLowerCase() === 'c' || e.key === 'Escape') clearAll();
            else if (e.key === 'Delete') clearAll();
        });

        confirmSaveBtn.addEventListener('click', () => {
            localStorage.setItem('saveHistoryPermission', 'true');
            permissionModalOverlay.classList.add('hidden');
            // After permission is granted, save the current history.
            renderHistory(); 
        });

        declineSaveBtn.addEventListener('click', () => {
            localStorage.setItem('saveHistoryPermission', 'false');
            permissionModalOverlay.classList.add('hidden');
        });

        window.addEventListener('beforeunload', (e) => {
            // Check if the user has not yet made a choice about saving history
            // and if there is history that would be lost.
            if (localStorage.getItem('saveHistoryPermission') === null && history.length > 0) {
                // This triggers the browser's built-in "Are you sure you want to leave?" confirmation dialog.
                e.preventDefault();
                // This is required for some older browsers to show the confirmation.
                e.returnValue = 'You have unsaved history. Please confirm you want to leave.';
            }
        });

        // --- Initial Load ---
        function initializeApp() {
            // Only load history if the user has previously given permission.
            if (localStorage.getItem('saveHistoryPermission') === 'true') {
                const savedHistory = localStorage.getItem('calculatorHistory');
                if (savedHistory) {
                    try {
                        history = JSON.parse(savedHistory);
                    } catch (e) {
                        console.error("Error parsing history from localStorage", e);
                        history = []; // Reset to empty array if data is corrupted
                    }
                }
            }
            updateDisplay();
            renderHistory();
        }

        initializeApp();
    </script>
</body>
</html>
